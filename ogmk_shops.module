<?php
/**
 * @file
 * Code for the Commerce Marketplace Shops feature.
 */

include_once 'ogmk_shops.features.inc';

/**
 * Hooks.
 */

/**
 * Implements hook_menu().
 */
function ogmk_shops_menu() {
  $items['node/%node/manage'] = array(
    'title'            => 'Shop Management',
    'access callback'  => '_ogmk_shops_shop_manage_access',
    'access arguments' => array(1),
    'page callback'    => '_ogmk_shops_shop_manage_page',
    'page arguments'   => array(1),
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'ogmk_shops.pages.inc',
  );

  /**
   * Placeholder menu item for using in dropdown menus in parent items.
   *
   * @Issue(
   *   "The placeholder menu item might better be moved to a base module"
   *   type="improvement"
   *   priority="low"
   *   labels="modularity"
   * )
   */
  $items['ogmk/placeholder'] = array(
    'title'           => 'OGMK Placeholder',
    'access callback' => TRUE,
    'page callback'   => '_ogmk_shops_placeholder_page',
    'type'            => MENU_CALLBACK,
    'file'            => 'ogmk_shops.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ogmk_shops_theme($existing, $type, $theme, $path) {
  return array(
    'shop_manage_page' => array(
      'variables' => array('variables' => NULL),
      'template'  => 'templates/pages/shop-manage',
    ),
  );
}

/**
 * Implements hook_form_alter().
 *
 * @Issue(
 *   "Consider moving form alterations not related to shops to
 *   ogmk_products module"
 *   type="improvement"
 *   priority="low"
 *   labels="modularity"
 * )
 */
function ogmk_shops_form_alter(&$form, &$form_state, $form_id) {
  // Process the "Add to cart" forms. They start with
  // "commerce_cart_add_to_cart_form_".
  if (strpos($form_id, 'commerce_cart_add_to_cart_form_') !== 0) {
    return;
  }

  // Add a label for the select widget.
  $form['product_id']['#title'] = t('Variant');

  // Set the shop for the line item.
  // @Issue(
  //   "Set the shop on submit callback from the selected variant instead of
  //   the default one"
  //   type="bug"
  //   priority="low"
  // )
  $productId = null;
  if (!empty($form['product_id']['#value'])) {
    $productId = $form['product_id']['#value'];
  } elseif (!empty($form['product_id']['#default_value'])) {
    $productId = $form['product_id']['#default_value'];
  } else {
    throw new \Exception('Cannot get the product id for the line item');
  }
  $product = commerce_product_load($productId);

  $language = $form['line_item_fields']['ogmk_shop_ref']['#language'];
  $form['line_item_fields']['ogmk_shop_ref'][$language][0]['default']['#default_value'] = [$product->ogmk_shop_ref[$product->language][0]['target_id']];
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ogmk_shops_form_ogmk_shop_node_form_alter(&$form, &$form_state, $form_id) {
  /**
   * @Issue(
   *   "Check if the user is super admin using a helper function"
   *   type="improvement"
   *   priority="low"
   *   labels="refactoring"
   * )
   * @Issue(
   *   "Revision and translation information should be available to the
   *   appropriate roles"
   *   type="bug"
   *   priority="normal"
   * )
   */
  global $user;
  if ($user->uid !== 1) {
    // Do not display translation and revision field groups.
    $form['revision_information']['#access'] = FALSE;
    $form['translation']['#access'] = FALSE;
  }

  // Add a Cancel button.
  $form['actions']['cancel'] = array(
    '#type' => 'button',
    '#access' => TRUE,
    '#value' => t('Cancel'),
    '#attributes' => array('onClick' => 'history.go(-1);return true;'),
    '#weight' => 7,
  );

  // Code specific to the edit form.
  if ($form['nid']['#value'] !== NULL) {
    // Add a Publish/Unpublish button.
    /**
     * @Issue(
     *   "Check publication permissions which might be different than update
     *   permissions"
     *   type="bug"
     *   priority="normal"
     *   labels="permissions, security"
     * )
     */
    $form['actions']['publish'] = array(
      '#type' => 'submit',
      '#access' => TRUE,
      '#weight' => 6,
      '#submit' => array(
        '_ogmk_shops_shop_publish_toggle_submit',
      )
    );

    // Customise button text and color depending on whether we are publishing or
    // unpublishing.
    if ($form['#node']->status) {
      $form['actions']['publish']['#value'] = t('Unpublish');
      $form['actions']['publish']['#attributes'] = array('class' => array('btn-danger'));
    }
    else {
      $form['actions']['publish']['#value'] = t('Publish');
      $form['actions']['publish']['#attributes'] = array('class' => array('btn-info'));
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @Issue(
 *   "Consider moving form alterations not related to shops to
 *   ogmk_products module"
 *   type="improvement"
 *   priority="low"
 *   labels="modularity"
 * )
 */
function ogmk_shops_form_ogmk_product_node_form_alter(&$form, &$form_state, $form_id) {
  // Code specific to the edit form.
  if ($form['nid']['#value']) {
    // @Issue(
    //   "Hide the translation vertical tab"
    //   type="improvement"
    //   priority="normal"
    // )
  }

  // Code specific to the edit form.
  if ($form['nid']['#value'] !== NULL) {
    // Add a Publish/Unpublish button.
    /**
     * @Issue(
     *   "Check publication permissions which might be different than update
     *   permissions"
     *   type="bug"
     *   priority="normal"
     *   labels="permissions, security"
     * )
     */
    $form['actions']['publish'] = array(
      '#type' => 'submit',
      '#access' => TRUE,
      '#weight' => 7,
      '#submit' => array(
        '_ogmk_shops_product_publish_toggle_submit',
      )
    );

    // Customise button text and color depending on whether we are publishing or
    // unpublishing.
    if ($form['#node']->status) {
      $form['actions']['publish']['#value'] = t('Unpublish');
      $form['actions']['publish']['#attributes'] = array('class' => array('btn-danger'));
    }
    else {
      $form['actions']['publish']['#value'] = t('Publish');
      $form['actions']['publish']['#attributes'] = array('class' => array('btn-info'));
    }
    // Add an Archive/Restore button.
    $form['actions']['archive'] = array(
      '#type' => 'submit',
      '#access' => TRUE,
      '#weight' => 6,
      '#submit' => array(
        '_ogmk_shops_product_archive_toggle_submit',
      )
    );

    // Customise button text and color depending on whether we are archiving or
    // restoring.
    $language = $form['ogmk_boolean']['#language'];
    if ($form['ogmk_boolean'][$language]['#default_value']) {
      $form['actions']['archive']['#value'] = t('Restore');
      $form['actions']['archive']['#attributes'] = array('class' => array('btn-info'));
    }
    else {
      $form['actions']['archive']['#value'] = t('Archive');
      $form['actions']['archive']['#attributes'] = array('class' => array('btn-info'));
    }
  }

  // Deny access to the archiving field ('ogmk_boolean'), since we are
  // displaying a button for the archive action.
  $form['ogmk_boolean']['#access'] = FALSE;

  // Deny access to ogmk_shop_ref field, unless the user is the administrator.
  /**
   * @Issue(
   *   "Check if the user is super admin using a helper function"
   *   type="improvement"
   *   priority="low"
   *   labels="refactoring"
   * )
   * @Issue(
   *   "Revision and translation information should be available to the
   *   appropriate roles"
   *   type="bug"
   *   priority="normal"
   * )
   */
  global $user;
  if ((int) $user->uid !== 1) {
    // If we hide the "ogmk_shop_ref" field on the edit form through the
    // "entityreference_prepopulate" module, it is also hidden for the super
    // admin user. We want to make it available to the super admin user.
    if ($form['nid']['#value']) {
      $form['ogmk_shop_ref']['#access'] = FALSE;
    }

    // Do not display translation and revision field groups.
    $form['revision_information']['#access'] = FALSE;
    $form['translation']['#access'] = FALSE;
  }

  // Add a Cancel button.
  $form['actions']['cancel'] = array(
    '#type' => 'button',
    '#access' => TRUE,
    '#value' => t('Cancel'),
    '#attributes' => array('onClick' => 'history.go(-1);return true;'),
    '#weight' => 8,
  );

  /**
   * @Issue(
   *   "The user should be redirected to the newly created product upon
   *   submission"
   *   type="improvement"
   *   priority="normal"
   *   labels="ux"
   * )
   */
}

function _ogmk_shops_product_publish_toggle_submit($form, &$form_state) {
  $node = $form['#node'];

  // Toggle the value of the 'status' field that indicates whether a node is
  // published or not.
  if ($node->status) {
    $node->status = 0;
    drupal_set_message(t('Product %title has been unpublished.', array('%title' => $node->title)));
  } else {
    $node->status = 1;
    drupal_set_message(t('Product %title has been published.', array('%title' => $node->title)));
  }

  node_save($node);

  // Set watchdog and Drupal message.
  $node_link = l(t('view'), 'node/' . $node->nid);
  $watchdog_args = array('@type' => $node->type, '%title' => $node->title);
  $t_args = array('@type' => node_type_get_name($node), '%title' => $node->title);
  watchdog('content', '@type: updated %title.', $watchdog_args, WATCHDOG_NOTICE, $node_link);

  if ($node->nid) {
    $form_state['values']['nid'] = $node->nid;
    $form_state['nid'] = $node->nid;
    $form_state['redirect'] = node_access('update', $node) ? 'node/' . $node->nid . '/edit' : '<front>';
  }
  else {
    // In the unlikely case something went wrong on save, the node will be
    // rebuilt and node form redisplayed the same way as in preview.
    drupal_set_message(t('The Product could not be saved.'), 'error');
    $form_state['rebuild'] = TRUE;
  }
  // Clear the page and block caches.
  cache_clear_all();
}

function _ogmk_shops_product_archive_toggle_submit($form, &$form_state) {
  $node = $form['#node'];
  $node_wrapper = entity_metadata_wrapper('node', $node);

  // Toggle the value of the 'status' field that indicates whether a node is
  // published or not.
  if ($node_wrapper->ogmk_boolean->value()) {
    $node_wrapper->ogmk_boolean->set(0);
    drupal_set_message(t('Product %title has been restored.', array('%title' => $node->title)));
  } else {
    $node_wrapper->ogmk_boolean->set(1);
    drupal_set_message(t('Product %title has been archived.', array('%title' => $node->title)));
  }

  $node_wrapper->save();

  // Set watchdog and Drupal message.
  $node_link = l(t('view'), 'node/' . $node->nid);
  $watchdog_args = array('@type' => $node->type, '%title' => $node->title);
  $t_args = array('@type' => node_type_get_name($node), '%title' => $node->title);
  watchdog('content', '@type: updated %title.', $watchdog_args, WATCHDOG_NOTICE, $node_link);

  if ($node->nid) {
    $form_state['values']['nid'] = $node->nid;
    $form_state['nid'] = $node->nid;
    $form_state['redirect'] = node_access('update', $node) ? 'node/' . $node->nid . '/edit' : '<front>';
  }
  else {
    // In the unlikely case something went wrong on save, the node will be
    // rebuilt and node form redisplayed the same way as in preview.
    drupal_set_message(t('The Product could not be saved.'), 'error');
    $form_state['rebuild'] = TRUE;
  }
  // Clear the page and block caches.
  cache_clear_all();
}

function _ogmk_shops_shop_publish_toggle_submit($form, &$form_state) {
  $node = $form['#node'];

  // Toggle the value of the 'status' field that indicates whether a node is
  // published or not.
  if ($node->status) {
    $node->status = 0;
    drupal_set_message(t('Shop %title has been unpublished.', array('%title' => $node->title)));
  } else {
    $node->status = 1;
    drupal_set_message(t('Shop %title has been published.', array('%title' => $node->title)));
  }

  node_save($node);

  // Set watchdog and Drupal message.
  $node_link = l(t('view'), 'node/' . $node->nid);
  $watchdog_args = array('@type' => $node->type, '%title' => $node->title);
  $t_args = array('@type' => node_type_get_name($node), '%title' => $node->title);
  watchdog('content', '@type: updated %title.', $watchdog_args, WATCHDOG_NOTICE, $node_link);

  if ($node->nid) {
    $form_state['values']['nid'] = $node->nid;
    $form_state['nid'] = $node->nid;
    $form_state['redirect'] = node_access('update', $node) ? 'node/' . $node->nid . '/edit' : '<front>';
  }
  else {
    // In the unlikely case something went wrong on save, the node will be
    // rebuilt and node form redisplayed the same way as in preview.
    drupal_set_message(t('The Shop could not be saved.'), 'error');
    $form_state['rebuild'] = TRUE;
  }
  // Clear the page and block caches.
  cache_clear_all();
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @Issue(
 *   "Consider setting the 'shop' for the 'commerce_product' using
 *   hook_entity_insert/update and by fetching the referencing node's 'shop'"
 *   type="bug"
 *   priority="normal"
 * )
 */
function ogmk_shops_inline_entity_form_entity_form_alter(&$entity_form, &$form_state) {
  // Set the shop field "ogmk_shop_ref" in the product ("commerce_product").
  // For now there is only manager per shop, the owner, so the shop would always
  // be the logged in user's shop.
  if ($entity_form['#entity_type'] !== 'commerce_product') {
    return;
  }

  $entity_form['#theme'] = ['product_product_ief_form'];
  $entity_form['ogmk_shop_ref']['#access'] = FALSE;

  // Get the Shop owned by the user.
  $shopId = ogmk_shops_user_has_shop();

  // Access denied no results found - the user is not a shop owner and therefore
  // can't create products.
  if (empty($shop)) {
    // @Issue(
    //   "Throw an Access Denied page or message"
    //   type="bug"
    //   priority="normal"
    //   labels="security"
    // )
  }

  // Pre-populate the ogmk_shop_ref field.
  $language = $entity_form['ogmk_shop_ref']['#language'];
  $entity_form['ogmk_shop_ref'][$language][0]['default']['#default_value'] = $shopId;
}

/**
 * Implements hook_entity_info_alter().
 */
function ogmk_shops_entity_info_alter(&$entity_info) {
  /**
   * @Issue(
   *   "Maybe this should be moved to a base ogmk module"
   *   type="task"
   *   priority="low"
   *   labels="modularity"
   * )
   */
  $entity_info['node']['view modes']['ogmk_manage_teaser'] = array(
    'label' => t('OGMK Management Teaser'),
    'custom settings' => FALSE,
  );
}

/**
 * Implements hook_entity_insert().
 */
function ogmk_shops_entity_insert($entity, $type) {
  // Subscribe to the OG "shop" group(s) they belong for all commerce_product,
  // commerce_order and commerce_line_item entities when they are created.
  $function = '_ogmk_shops_' . $type . '_og_subscribe';
  if (function_exists($function)) {
    $function($entity, $type);
  }
}

/**
 * Implements hook_entity_update().
 */
function ogmk_shops_entity_update($entity, $type) {
  // Update subscriptions to the OG "shop" group(s) they belong for all
  // commerce_product, commerce_order and commerce_line_item entities when they
  // are updated.
  $function = '_ogmk_shops_' . $type . '_og_subscribe';
  if (function_exists($function)) {
    $function($entity, $type);
  }
}

/**
 * Implements hook_entity_delete().
 */
function ogmk_shops_entity_delete($entity, $type) {
  // Remove all OG subscriptions for all commerce_product, commerce_order and
  // commerce_line_item entities when they are deleted.
  $function = '_ogmk_shops_' . $type . '_og_unsubscribe';
  if (function_exists($function)) {
    $function($entity, $type);
  }
}

/**
 * Implements hook_menu_token_plugins().
 */
function ogmk_shops_menu_token_plugins() {
  $plugins = array();

  $plugins["ogmk_current_user_shop"] = array(
    'type' => 'node',
    'label' => t('Current user\'s shop'),
    'description' => t('Picks the shop owned by the logged in user.'),
    'handler' => array(
      'path' => drupal_get_path('module', 'ogmk_shops') . '/includes/menu_token',
      'file' => 'menu_token_ogmk_current_user_shop.inc',
      'class' => 'menu_token_ogmk_current_user_shop',
    ),
  );

  $plugins["ogmk_og_context_shop"] = array(
    'type' => 'node',
    'label' => t('Shop from OG context'),
    'description' => t('Picks the shop from the current OG context.'),
    'handler' => array(
      'path' => drupal_get_path('module', 'ogmk_shops') . '/includes/menu_token',
      'file' => 'menu_token_ogmk_og_context_shop.inc',
      'class' => 'menu_token_ogmk_og_context_shop',
    ),
  );

  return $plugins;
}

/**
 * Implements hook_og_permission().
 */
function ogmk_shops_og_permission() {
  // Create permissions for orders. They will be used to control access on
  // orders that have items from a given shop.
  $og_permissions = commerce_entity_access_permissions('commerce_order');

  // Create one permission for each OG role.
  $og_roles = og_roles('node', 'ogmk_shop');

  foreach ($og_roles as $og_role) {
    if (in_array($og_role, array(OG_ANONYMOUS_ROLE))) {
      continue;
    }

    $og_permissions['have the ' . $og_role . ' role'] = array(
      'title' => t('Have the <em>@og_role</em> role in the group', array('@og_role' => $og_role)),
      'description' => t('This permission should be assigned only to the corresponding OG role. It is meant to be used in cases where a role check is required, but a permission check is preferrable, such as when exporting Views access control via Features.'),
      'roles' => array(OG_AUTHENTICATED_ROLE),
    );
  }

  return $og_permissions;
}

/**
 * Implements hook_og_context_negotiation_info().
 */
function ogmk_shops_og_context_negotiation_info() {
  $providers = array();

  $providers['ogmk_shop_views'] = array(
    'name' => t('OGMK Shop View Pages'),
    'description' => t("Determine context by the url argument that specifies the Shop currently being viewed or managed."),
    'callback' => '_ogmk_shops_node_views_og_context_handler',
    'menu path' => array(
      // Shop front views.
      'node/%/products',
      'node/%/reviews',
      // Shop management views.
      'node/%/manage/orders',
      'node/%/manage/orders/%',
      'node/%/manage/products',
    ),
  );

  return $providers;
}

/**
 * Context handler for views;
 *
 * Gets the group ("shop" node) from the url.
 */
function _ogmk_shops_node_views_og_context_handler() {
  $item = menu_get_item();

  if (empty($item['map'])) {
    // User has no access to the menu item.
    return;
  }

  $node = node_load($item['map'][1]);

  if (isset($node) && $node) {
    return _group_context_handler_entity('node', $node);
  }
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_user_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter($query, 'users', 'uid');
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_user_published_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'users',
    'uid',
    [
      'status' => TRUE,
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_user_unpublished_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'users',
    'uid',
    [
      'status' => FALSE,
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter($query, 'node', 'nid');
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_published_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'node',
    'nid',
    [
      'status' => TRUE,
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_unpublished_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'node',
    'nid',
    [
      'status' => FALSE,
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_ogmk_product_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'node',
    'nid',
    [
      'bundle' => 'ogmk_product',
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_ogmk_product_published_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'node',
    'nid',
    [
      'bundle' => 'ogmk_product',
      'status' => TRUE,
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_ogmk_product_unpublished_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'node',
    'nid',
    [
      'bundle' => 'ogmk_product',
      'status' => FALSE,
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_ogmk_review_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'node',
    'nid',
    [
      'bundle' => 'ogmk_review',
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_ogmk_review_published_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'node',
    'nid',
    [
      'bundle' => 'ogmk_review',
      'status' => TRUE,
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_node_ogmk_review_unpublished_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'node',
    'nid',
    [
      'bundle' => 'ogmk_review',
      'status' => FALSE,
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_commerce_line_item_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter($query, 'commerce_line_item', 'line_item_id');
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_membership_commerce_line_item_ogmk_product_alter(QueryAlterableInterface $query) {
  _ogmk_shops_create_ogmK_membership_query_alter(
    $query,
    'commerce_line_item',
    'line_item_id',
    [
      'bundle' => 'ogmk_product',
    ]
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_line_item_order_status_canceled_alter(QueryAlterableInterface $query) {
  $query->innerJoin('commerce_order', 'commerce_order', 'commerce_order.order_id = commerce_line_item.order_id');
  $query->condition('commerce_order.status', 'canceled');
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_line_item_order_status_pending_alter(QueryAlterableInterface $query) {
  $query->innerJoin('commerce_order', 'commerce_order', 'commerce_order.order_id = commerce_line_item.order_id');
  $query->condition('commerce_order.status', 'pending');
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_line_item_order_status_processing_alter(QueryAlterableInterface $query) {
  $query->innerJoin('commerce_order', 'commerce_order', 'commerce_order.order_id = commerce_line_item.order_id');
  $query->condition('commerce_order.status', 'processing');
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_line_item_order_status_completed_alter(QueryAlterableInterface $query) {
  $query->innerJoin('commerce_order', 'commerce_order', 'commerce_order.order_id = commerce_line_item.order_id');
  $query->condition('commerce_order.status', 'completed');
}

/**
 * Implements hook_query_TAG_alter().
 */
function ogmk_shops_query_ogmk_line_item_order_status_cart_alter(QueryAlterableInterface $query) {
  $query->innerJoin('commerce_order', 'commerce_order', 'commerce_order.order_id = commerce_line_item.order_id');
  $query->condition('commerce_order.status', 'cart');
}

/**
 * Public API.
 */

/**
 * @param int|object $user
 *   The user id or object for whom to check if there is a shop.
 *   If NULL is given, the logged in user will be checked for.
 *
 * @return int
 *   Zero (0) if there is no shop owned by the user.
 *   The shop's id otherwise.
 */
function ogmk_shops_user_has_shop($user = NULL) {
  if ($user === NULL) {
    global $user;
  }

  $userId = NULL;
  if (is_int($user)) {
    $userId = $user;
  } else {
    $userId = $user->uid;
  }

  // Anonymous users can't have shops.
  if ($userId === 0) {
    return FALSE;
  }

  // Get the Shop owned by the user.
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node', '=')
    ->propertyCondition('uid', $userId)
    ->propertyCondition('type', 'ogmk_shop');
  $result = $query->execute();

  if (empty($result['node'])) {
    return 0;
  }

  // Get the first key of the result array because there should be only one
  // result.
  return key($result['node']);
}

/**
 * @param int|object $user
 *   The user id or object for whom to check if there is a shop.
 *   If NULL is given, the logged in user will be checked.
 *
 * @return null|object
 *   NULL if there is no shop owned by the user.
 *   The shop's object otherwise.
 */
function ogmk_shops_user_get_shop($user = NULL) {
  $shopId = ogmk_shops_user_has_shop($user);

  if ($shopId) {
    return node_load($shopId);
  }

  return NULL;
}

/**
 * Get the number of entities that are members of a shop.
 *
 * Entities to be counted can be filtered by using the various options provided.
 *
 * @param object $shop
 *   The 'shop' node object for which to get the number of members.
 * @param array $options
 *   An array of options, @see _ogmk_shops_shop_members_query.
 *
 * @return int
 *   The number of shop members.
 */
function ogmk_shops_shop_nb_members($shop, array $options = array()) {
  // Get the query to execute.
  $query = _ogmk_shops_shop_members_query($shop, $options);

  // Execute the query and return the result.
  return $query->count()->execute();
}

/**
 * Get the number of active shop user members.
 *
 * Only active users with an active 'ogmk_shop_member' membership will be
 * counted.
 *
 * @param object $shop
 *   The 'shop' node object for which to get the number of active users.
 *
 * @return int
 *   The number of active shop users.
 */
function ogmk_shops_shop_nb_active_users($shop) {
  return ogmk_shops_shop_nb_members(
    $shop,
    array(
      'entity_type'      => 'user',
      'entity_status'    => TRUE,
      'membership_state' => OG_STATE_ACTIVE,
      'membership_type'  => 'ogmk_shop_member',
    )
  );
}

/**
 * Get the number of published products that belong to a shop.
 *
 * @param object $shop
 *   The 'shop' node object for which to get the number of published products.
 *
 * @return int
 *   The number of products published on the given shop.
 */
function ogmk_shops_shop_nb_published_products($shop) {
  return ogmk_shops_shop_nb_members(
    $shop,
    array(
      'entity_type'      => 'node',
      'entity_bundle'    => 'ogmk_product',
      'entity_status'    => TRUE,
      'membership_state' => OG_STATE_ACTIVE,
    )
  );
}

/**
 * Get the number of published reviews that belong to a shop.
 *
 * Shop reviews are essentially reviews for products that belong to the given
 * shop.
 *
 * @param object $shop
 *   The 'shop' node object for which to get the number of published reviews.
 *
 * @return int
 *   The number of published shop reviews.
 */
function ogmk_shops_shop_nb_published_reviews($shop) {
  return ogmk_shops_shop_nb_members(
    $shop,
    array(
      'entity_type'      => 'node',
      'entity_bundle'    => 'ogmk_review',
      'entity_status'    => TRUE,
      'membership_state' => OG_STATE_ACTIVE,
    )
  );
}

/**
 * Get the number of line items that belong to a shop.
 *
 * @param object $shop
 *   The 'shop' node object for which to get the number of line items.
 * @param array $options
 *   An array of options. Available options are:
 *   - entity_bundle: (null|boolean) The entity bundle to look for. If NULL, all
 *     line items will be counted regardless of their bundle.
 *   - membership_state: (NULL|int) The OG membership state to look for. If
 *     NULL, all line items will be counted regardless of their membership
 *     state.
 *   - membership_type: (NULL|string) The OG membership type to look for. If
 *     NULL, all line items will be counted regardless of their membership type.
 *
 * @return int
 *   The number of line items for the given shop.
 */
function ogmk_shops_shop_nb_line_items($shop, array $options = array()) {
  // By default, count only active/published entities with active membership
  // state.
  $options = array_merge(
    array(
      'entity_bundle'    => NULL,
      'membership_state' => OG_STATE_ACTIVE,
      'membership_type'  => NULL,
      'order_status'     => NULL,
    ),
    $options
  );

  // The entity type should always be that of a line item.
  $options['entity_type'] = 'commerce_line_item';

  // Line items do not have a status property.
  $options['entity_status'] = NULL;

  // Make the join with the 'commerce_line_item' table even if we are not
  // interested in any of its properties (bundle) so that we can then make a
  // join with the 'commerce_order' table.
  if (empty($options['entity_bundle'])) {
    $options['empty_join'] = TRUE;
  }

  // Construct the query which includes the join with the 'commerce_line_item'
  // table, if required.
  $query = _ogmk_shops_shop_members_query($shop, $options);

  // If there's no specific order status requested, we don't need to add a join
  // with the 'commerce_order' table. Get and return the results.
  if (empty($options['order_status'])) {
    return $query->count()->execute();
  }

  // Restrict results to the order status requested using the appropriate query
  // tag.
  $query_tag = 'ogmk_line_item_order_status_' . $options['order_status'];

  // Throw an exception if the hook doesn't exist to warn the developer.
  if (!function_exists('ogmk_shops_query_' . $query_tag . '_alter')) {
    throw new Exception(sprintf('The query tag "%s" has been called, but its corresponding hook_query_alter() hook has not been defined.', $query_tag));
  }

  // Add the tag that will alter the query so that it picks up line items only
  // from order with the desired status.
  $query->addTag($query_tag);

  return $query->count()->execute();
}


/**
 * Get the number of fulfilled line items that belong to a shop.
 *
 * Fulfilled means that the order in which the line item belong has its status
 * set to 'completed'.
 *
 * @param object $shop
 *   The 'shop' node object for which to get the number of line items.
 *
 * @return int
 *   The number of fulfilled line items for the given shop.
 */
function ogmk_shops_shop_nb_fulfilled_line_items($shop) {
  return ogmk_shops_shop_nb_line_items(
    $shop,
    [
      'order_status' => 'completed',
    ]
  );
}

/**
 * Functions for internal use.
 */

/**
 * Access callback for the shop management page.
 *
 * @param object $shop
 *   The shop for which to display the management page.
 *
 * @return boolean
 *   Whether the current user has access or not to the shop management page.
 */
function _ogmk_shops_shop_manage_access($shop) {
  if ($shop->type !== 'ogmk_shop') {
    return FALSE;
  }

  // The super admin user should have access to this page.
  /**
   * @Issue(
   *   "Check if the user is super admin with a helper function"
   *   type="improvement"
   *   priority="normal"
   * )
   * @Issue(
   *   "Add OG permissions for the various shop management pages"
   *   type="improvement"
   *   priority="normal"
   *   labels="security"
   * )
   */
  global $user;
  if ($user->uid == 1) {
    return TRUE;
  }

  // Give access to user members of the shop with the 'manager member' or
  // 'administrator member' role.
  $og_roles = og_get_user_roles('node', $shop->nid, NULL, FALSE);
  if (in_array('manager member', $og_roles) || in_array('administrator member', $og_roles)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Subscribes a "commerce_order" entity to all "shop" OG groups it belongs to.
 *
 * The order belongs to all "shop" OG groups that the order's products
 * ("commerce_line_item") belong to.
 */
function _ogmk_shops_commerce_order_og_subscribe($entity, $type) {
  // Nothing to do if there's no line items in the order.
  // This can happen sometimes with abandon carts, I believe.
  if (empty($entity->commerce_line_items)) {
    return;
  }

  // Get all the line items for the order.
  /**
   * @Issue(
   *   "Check if commerce_line_item use other than LANGUAGE_NONE"
   *   type="bug"
   *   priority="low"
   *   labels="internationalisation"
   * )
   */
  $lineItemsIds = [];
  foreach ($entity->commerce_line_items[LANGUAGE_NONE] as $item) {
    $lineItemsIds[] = $item['line_item_id'];
  }
  $lineItems = commerce_line_item_load_multiple($lineItemsIds);

  // Get all shop ids for all line items - we get the shops from the products
  // referenced by the line items.
  $shopsIds = [];
  foreach ($lineItems as $lineItem) {
    // We don't take into account other line items, such as shipping.
    /**
     * @Issue(
     *   "Find a better way to detect which line items to take into account when
     *   calculating the shops to add the order to"
     *   type="bug"
     *   priority="low"
     * )
     */
    if ($lineItem->type !== 'ogmk_product') {
      continue;
    }

    $lineItemWrapper = entity_metadata_wrapper('commerce_line_item', $lineItem);

    $product = $lineItemWrapper->commerce_product->value();
    $productWrapper = entity_metadata_wrapper('commerce_product', $product);

    $shop = $productWrapper->ogmk_shop_ref->value();
    $shopWrapper = entity_metadata_wrapper('node', $shop);
    $shopId = $shopWrapper->getIdentifier();

    // Continue to the next line item if the shop has already been added.
    if (in_array($shopId, $shopsIds)) {
      continue;
    }

    // Subscribe the order to the shop.
    og_group(
      'node',
      $shopId,
      [
        'entity_type' => $type,
        'entity' => $entity,
        'state' => OG_STATE_ACTIVE,
      ]
    );

    // Keep track of shop already added.
    $shopsIds[] = $shopId;
  }

  // Subscribe the owner of the order to all shops involved in the order as
  // well, but only if the order is fully submitted.
  /**
   * @Issue(
   *   "Check if the 'cancelled' status should be excluded as well"
   *   type="bug"
   *   priority="normal"
   * )
   */
  if (strpos($entity->status, 'cart') === 0 || strpos($entity->status, 'checkout') === 0) {
    return;
  }

  // Can't subscribe anonymous users.
  if ($entity->uid == 0) {
    return;
  }

  // Add the OG user membership.
  foreach ($shopsIds as $shopId) {
    og_group(
      'node',
      $shopId,
      [
        'entity_type' => 'user',
        'entity' => $entity->uid,
        'field_name' => 'ogmk_user_shops_ref',
        'state' => OG_STATE_ACTIVE,
      ]
    );
  }
}

/**
 * Subscribes a "commerce_line_item" entity to the "shop" OG group it belongs to.
 *
 * The line item belongs to the "shop" OG group that the referenced product
 * belongs to.
 */
function _ogmk_shops_commerce_line_item_og_subscribe($entity, $type) {
  // We don't subscribe irrelevant line items, such as shipping, to a specific
  // shop.
    /**
     * @Issue(
     *   "Find a better way to detect which line items to subscribe to their
     *   shops"
     *   type="bug"
     *   priority="low"
     * )
     */
  if ($entity->type !== 'ogmk_product') {
    return;
  }

  /**
   * @Issue(
   *   "Does this work with internationalisation?"
   *   type="bug"
   *   priority="normal"
   *   labels="internationalisation"
   * )
   */
  // Get the line item's product.
  $productId = $entity->commerce_product[LANGUAGE_NONE][0]['product_id'];
  $product = commerce_product_load($productId);

  // Get the product's shop.
  $productWrapper = entity_metadata_wrapper('commerce_product', $product);
  $shopId = $productWrapper->ogmk_shop_ref->value();

  // Subscribe the line item to the shop.
  $result = og_group(
    'node',
    $shopId,
    [
      'entity_type' => $type,
      'entity' => $entity,
      'state' => OG_STATE_ACTIVE,
    ]
  );
}

/**
 * @Issue(
 *   "Write og_unsubscribe functions"
 *   type="bug"
 *   priority="normal"
 * )
 */

/**
 * Generate the query for getting the entities that are member of a shop.
 *
 * @param object $shop
 *   The 'shop' node object for which to get the member entities.
 * @param array $options
 *   An array of options. Available options are:
 *   - entity_type: (null|boolean) The entity type to look for. Required if a
 *     specific entity bundle is given. If NULL, all entities of all types will
 *     be requested in the query.
 *   - entity_bundle: (null|boolean) The entity bundle to look for. If NULL, all
 *     entities will be requested regardless of their bundle.
 *   - entity_status: (null|boolean) The status property (usually implying
 *     publication status) to look for. If NULL, all entities will be requested
 *     regardless of their status.
 *   - membership_state: (NULL|int) The OG membership state to look for. If
 *     NULL, all entities will be requested regardless of their membership
 *     state.
 *   - membership_type: (NULL|string) The OG membership type to look for. If
 *     NULL, all entities will be requested regardless of their membership type.
 *   - empty_join: (boolean) Whether or not to issue a join with the requested
 *     entity's table, even when there is no property to be queried on that
 *     table. This can be useful when the join is used to then reach another
 *     table with another join, e.g. to reach a shop's order property through
 *     it's line items.
 *
 * @return EntityFieldQuery
 *   The built query for getting the shop's member entities.
 */
function _ogmk_shops_shop_members_query($shop, array $options = array()) {
  // By default, count only active/published entities with active membership
  // state.
  $options = array_merge(
    array(
      'entity_type'      => NULL,
      'entity_bundle'    => NULL,
      'entity_status'    => TRUE,
      'membership_state' => OG_STATE_ACTIVE,
      'membership_type'  => NULL,
      'empty_join'       => FALSE,
    ),
    $options
  );

  // Throw an exception if a bundle is requested but no entity type has been
  // defined.
  if (!empty($options['entity_bundle']) && empty($options['entity_type'])) {
    throw new Exception('You must specify an entity type in order to restrict results to a specific entity bundle.');
  }

  // Throw an exception if a bundle is requested but no entity type has been
  // defined. This is because we need to know the entity type in order to add
  // the appropriate query tag.
  if ($options['entity_bundle'] === NULL && empty($options['entity_type'])) {
    throw new Exception('You must specify an entity type in order to restrict results to a specific entity status.');
  }

  // Construct the query.
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'og_membership')
    ->propertyCondition('group_type', 'node')
    ->propertyCondition('gid', $shop->nid);

  if (!empty($options['entity_type'])) {
    $query->propertyCondition('entity_type', $options['entity_type']);
  }

  if (!empty($options['membership_state'])) {
    $query->propertyCondition('state', $options['membership_state']);
  }

  if (!empty($options['membership_type'])) {
    $query->propertyCondition('type', $options['membership_type']);
  }

  // If the 'entity_bundle' option is NULL, and the 'entity_status' option is
  // NULL as well (which means that we want the total count of entities whether
  // they are published or not), there's no query tag to add. Get the result and
  // return it.
  // If the 'empty_join' option is set to TRUE, we will continue with the query
  // as normal to allow for a join without querying for any properties.
  if (empty($options['entity_bundle']) && $options['entity_status'] === NULL && $options['empty_join'] === FALSE) {
    return $query;
  }

  // In all other cases we will add the appropriate query tag.
  $published_tag_label = '';
  // Switch statements does not type check and does not work well - let's use if
  // statements to be sure.
  if ($options['entity_status'] === TRUE) {
    $published_tag_label = '_published';
  }
  elseif ($options['entity_status'] === FALSE) {
    $published_tag_label = '_unpublished';
  }

  $entity_bundle_label = '';
  if (!empty($options['entity_bundle'])) {
    $entity_bundle_label = '_' . $options['entity_bundle'];
  }

  $query_tag = 'ogmk_membership_' . $options['entity_type'] . $entity_bundle_label . $published_tag_label;

  // Since this contains the potential of counting unpublished records if a
  // bundle is requested without defining the appropriate hook, it's better to
  // throw an exception if the hook doesn't exist.
  if (!function_exists('ogmk_shops_query_' . $query_tag . '_alter')) {
    throw new Exception(sprintf('The query tag "%s" has been called, but its corresponding hook_query_alter() hook has not been defined.', $query_tag));
  }

  $query->addTag($query_tag);

  return $query;
}

/**
 * Perform the query alterations required for the ogmk_membership set of tags.
 *
 * It adds a join with the requested entity table, and looks for the 'bundle'
 * and 'status' property values, if requested.
 *
 * @Issue(
 *   "Test more thoroughly if this query alteration works as expected"
 *   type="bug"
 *   priority="normal"
 *   labels="security, testing"
 * )
 *
 * @param QueryAlterableInterface $query
 *   The query to alter as made available by hook_query_TAG_alter().
 * @param string $table
 *   The name of the entity table on which the join will be performed.
 * @param string $id_column
 *   The entity identifier column.
 * @param array $options
 *   An array of options: Available options are:
 *   - bundle: (null|boolean) The entity bundle to look for. If NULL, all
 *     entities will be requested regardless of their bundle.
 *   - status: (null|boolean) The status property (usually implying publication
 *     status) to look for. If NULL, all entities will be requested regardless
 *     of their status.
 */
function _ogmk_shops_create_ogmk_membership_query_alter(QueryAlterableInterface $query, $table, $id_column, array $options = array()) {
  $options = array_merge(
    array(
      'bundle' => NULL,
      'status' => NULL,
    ),
    $options
  );

  // We may want to keep the join even when no specific bundle or status are
  // required, because we may want to use the entity to join with another table
  // e.g. reach the order through a line item.
  $query->innerJoin($table, $table, $table . '.' . $id_column . ' = og_membership.etid');

  if (!empty($options['bundle'])) {
    $query->condition($table . '.type', $options['bundle']);
  }

  if ($options['status'] !== NULL) {
    $query->condition($table . '.status', $options['status']);
  }
}
